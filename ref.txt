Week1 - 
    - Core Java - oops, collections, exceptions, threading, io
    - JDBC 
    - JPA 
    - Servlet
    - Spring Core 
    - Spring MVC 
    - Spring Data JPA 
    - Spring Data REST 
    - Spring Boot 

Week2 
    - Spring Security 
    - Microservices 
    - AWS 
week3
    - Misc 

Week4 
    - HTML, CSS, JS, Typescript 
    - Angular 

language                    library                     framework 

Java                                                    spring 
C#                                                      .net framework 
javascript                  react                       angular
Python                                                  django                                



Java7, 8, 9, 15...

Programming language 

Platform - runtime environment 

Standard libraries 



JDBC API
-----------
    - Specification / set of interfaces which defines how to access a database 


    - JDBC Drivers 

    - java.sql and javax.sql packages 


    JavaApplication ---> JDBC API -----> JDBC Driver -----> database 


    JDBC API - Appication to JDBC manager Connection 
    JDBC Driver API - JDBC Manager -- Driver Connection



        Class.forName("driverclass")


        DriverManager 
            - getConnection()
            - getDrivers()




    JDBC 

            - load the drivers 
            - establish the connection 

                 Connection conection =    DriverManager.getConnection("","","");

            - create Statement object 

                - Statement 
                      Statement stmt =   connection.createStatement()

                        int result = stmt.executeUpdate("sqlcommand")       //insert/udpate/delete

                         int result = stmt.executeUpdate("INSERT INTO employee values('"+empname+"', '"+city+"', 1000.00)") 

                        ResultSet rs =  stmt.executeQuery("sqlcommand")

                        boolean result =  stmt.execute("sqlcommand")

                    - the sqlcommand is compiled everytime at db side
                    - slower if consecutive execution of same query 
                    - statement object can be only used to execute "string based" sql queries 

                    -** Statement object is suitable for CREATE, Alter, Drop tables 
                            -- good for DDL Queries 

                    -** statement object can't be used for storing & retrieving binary data i.e. arrays, files etc. 
                    -** with statement object, it is "vulnerable to SQL Injections" 

                        string ename = "---"
                        String query = "INSERT INTO employees (id, name) values(1, '"+ename+"')"


                - PreparedStatement 
                    - PS  object can be only used to execute "parameterized" sql queries 

                     String query = "INSERT INTO employees (id, name) values(?,?)"; 

                     PreparedStatement ps = connection.prepareStatement(query)

                --** it has methods to bind various object types 
                        ps.setXXXXX(placeholderindex, value)
                --** it protects against "SQL Injections"
                --** uses pre-compilations 
                --** speeds up the communication between database and jvm 
                --** PS provides "batch" execution during single db connection 
                --** PS is good for DML queries 


                - CallableStatement 




            - Execute the statement / db commands 
            - close connection 


            - Batch Processing in JDBC 


JDBC 


Object Persistence 
    - state of an object can be stored in data store, and re-created at a later point of time 
    - you can persist the data in files/relational databases 




ORM - object relation mapping tools 
    - Map the Object Model to Relational model 
    - ORM is a technique to map the representation of data from java objects to relational database tables (and vise versa) 
    - this mapping is done either using xml or annotations 
    - hides the complexity to deal with sql and low level jdbc api 


    Hibernate                           Hibernate JPA 

    Ibatis                              MyBatis

    TopLink                             EclipseLink


Hibernate xml configuration
------------------------------
    <hibernate-configuration>
        <session-factory>
                //..db configuration
        </session-factory>
    </hibernate-configuration>


JPA - Java Persistence API 
---------------------------------
    - standard specification for object mapping 

 
JPA Providers 
---------------
    - implementation of jpa 

    - Hibernate JPA
    - MyBatis
    - EclipseLink


Entity 
------------
    - Entity represents the data to be persisted, queried, or the data to be manipulated 
             - Java Object --> just instance of a class 
    - Entities are objects which are persisted / managed by the EntityManager 

    - must have no-arg constructor 
    - must have identifier column marked with @Id annotation
    - can be concrete or abstract class 
    - enums or interfaces cannot be entities 
    - all attributes of the entity class become persistent by default 

    @Entity
    class Book {

        @Id
        private long id; 
        private String title; 

        //constructor 
        //getter/setter 
        
    }

EntityManager
---------------
    - object which manages PersistenceContext 
    - EntityManager object is used to persist the Entities 

                                                  Persistence 
                                                        |
        persistence.xml                             (create)
            |                                            |
        PersistentUnit                         EntityManagerFactory
            |                                            |
         (Configuredby)                              (creates)
            |                                           |
         PersistenceContext<------- (manages)------"EntityManager"


PersistenceContext 


PersistentUnit 
    - a named configuration of a set of entities 

   <persistence-unit name="jpademo1">

	</persistence-unit>


Default Mapping 

    - by default the table name is similar to the entity class name 
    - column names in the table will be similar to attribute names 
    - jdbc rules applied for mapping java primitives to relational data types 
            - string    = varchar(255)
            - long      = bigint 
            - boolean   = smallint 
            - enums     = integer

Custom Mapping 

    - @Table(name="new_table_name", schema="xxxxxx")
    - @Column(name="column_name", length="300", nullable=true)
    - @Temporal(TemporalType.DATE)

    - @GeneratedValue(strategy="xxxx")
        - GenerationType.SEQUENSE 
        - GenerationType.IDENTITY 
        - GenerationType.TABLE 
        - GenerationType.AUTO


CRUD operations on Entity 


Transaction 


Relationships 

    Department      <----has-A------> Employee

    class Department {                      class Employee {
        int deptId;                                 /...
        String deptName;                            /....
                                                    @OneToOne
        ....                                        Department dept;
        @OneToMany
        Set<Employee> employees;
    }                                       }

    deptTable
    -------------
    deptId          deptName  
    1               xxxxx   

    department_employee
    ---------------------
    department_deptId           employee_empId
    1                           1
    1                           2
    1                           3
   

    empTable                        //joinColumn
    ---------
    empId           empName         department_deptId
    1               xxx             1
    2               xxx             1
    3               xxx             2
    5               xxx             1





    Book           <----->       Author 



    Direction 

    Cardinality 


Default mapping strategy 
------------------------------

    @OneToOne           ---> Join column 
    @ManyToOne          ---> Join Column

    @OneToMany          ---> Join Table
    @ManyToMany         ---> Join Table 


    @Entity                                     @Entity 
    class Book {                                class Author {
        //..                                        //..
        //..                                        //...
        @OneToMany                                  //...
        List<Author> authors;                       
    }                                           }


        book -table                         author-table                book_author-table 
        -------



    Department  ---------> Employee




    @Entity                             @Entity 
    class Book {                        class Author {
        //..                                //..

        @OneToOne                           @OneToMany
        Author author;                      List<Book> books;

    }                                   }


    Book        1--->1      Author 

    Author      1--->*      Book



    book-table      
    --------------
    bookid          title       desc        author_id


    author-table 
    ----------------



    author_book 
    -------------
    author_id       book_id 

















Cascade events 


Fetching relationships 

    - default fetch policy 
            @OneToOne       -- Eager 
            @OneToMany      -- Eager 

            @ManyToOne      - Lazy
            @ManyToMany     - Lazy 
    - custom fetch policy 


Inheritance in jpa 
    - inheritance strategies 

quering the entities
    - JPQL
    - custom jpql queries - named queries / dynamic queries 
    - native sql queries 
    - criteria api 
    - querydsl

Spring Data JPA 